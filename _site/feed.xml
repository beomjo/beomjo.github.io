<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-09-26T23:53:36+09:00</updated><id>/feed.xml</id><title type="html">Beom Log</title><subtitle>beomjo amazing website.</subtitle><author><name>beomjo</name></author><entry><title type="html">Jekyll, minimal-mistakes 테마를 적용하기</title><link href="/blogs/create-blog/" rel="alternate" type="text/html" title="Jekyll, minimal-mistakes 테마를 적용하기" /><published>2021-06-29T00:00:00+09:00</published><updated>2021-06-29T00:00:00+09:00</updated><id>/blogs/create-blog</id><content type="html" xml:base="/blogs/create-blog/">&lt;h2 id=&quot;설정&quot;&gt;설정&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Github Pages 호스팅을 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;${GITHUB_ID}.github.io&lt;/code&gt; 라는 이름으로 리파지토리를 생성해야 한다&lt;/li&gt;
  &lt;li&gt;Gem을 이용해서 Jekyll 을 설치한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;테마-적용&quot;&gt;테마 적용&lt;/h2&gt;
&lt;p&gt;minimal-mistake &lt;a href=&quot;https://mmistakes.github.io/minimal-mistakes/docs/quick-start-guide/&quot;&gt;빠른 시작 가이드&lt;/a&gt;를 참고하여 진행한다.&lt;br /&gt;
&lt;a href=&quot;https://github.com/mmistakes/minimal-mistakes&quot;&gt;minimal-mistake&lt;/a&gt; Repository에서 소스를 가져와 옮긴다.&lt;br /&gt;
옮긴 후 다음 과정을 진행한다.&lt;/p&gt;

&lt;h3 id=&quot;불필요-내용-제거&quot;&gt;불필요 내용 제거&lt;/h3&gt;
&lt;p&gt;minimal-mistakes-jekyll repository에서 소스를 가져왔다면 불필요한 내용을 제거한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;.editorconfig&lt;/li&gt;
  &lt;li&gt;.gitattributes&lt;/li&gt;
  &lt;li&gt;.github&lt;/li&gt;
  &lt;li&gt;/docs&lt;/li&gt;
  &lt;li&gt;/test&lt;/li&gt;
  &lt;li&gt;CHANGELOG.md&lt;/li&gt;
  &lt;li&gt;minimal-mistakes-jekyll.gemspec&lt;/li&gt;
  &lt;li&gt;README.md&lt;/li&gt;
  &lt;li&gt;screenshot-layouts.png&lt;/li&gt;
  &lt;li&gt;screenshot.png&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;_config-파일-설정&quot;&gt;_config 파일 설정&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yaml&lt;/code&gt; 파일에서 아래와 값들을 설정해준다&lt;/p&gt;

&lt;h4 id=&quot;기본-구성&quot;&gt;기본 구성&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Site Settings
minimal_mistakes_skin    : &quot;dark&quot;
title                    : &quot;Beom Log&quot;
name                     : &quot;취미코딩하는 개발자&quot;
description              : &quot;회사에서는 월급 받고 집에서는 취미로 코딩하는 개발자의 블로그&quot;
url                      : &quot;https://beomjo.github.io&quot;
baseurl                  : # 서브 경로가 있는 경우 기재
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;teaser와-logo-그림-파일&quot;&gt;teaser와 logo 그림 파일&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;teaser                   : &quot;/assets/images/bio.jpg&quot;
logo                     : # 최상단 메뉴 바에 사이트 로고 넣기
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;댓글&quot;&gt;댓글&lt;/h4&gt;
&lt;p&gt;블로그 댓글 기능 disqus, discourse, facebook, staticman, utterances 정도가 대표적이다. &lt;br /&gt;
GitHub Pages 자체적으로 댓글을 제공하고 있지 않기때문에 보통 외부 댓글 서비스를 연결해주는 방식을 사용한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;comments:
  provider               : # 블로그 댓글 기능 false (default), &quot;disqus&quot;, &quot;discourse&quot;, &quot;facebook&quot;, &quot;staticman&quot;, &quot;staticman_v2&quot;, &quot;utterances&quot;, &quot;custom&quot;
  disqus:
    shortname            : # 블로그 댓글 기능 https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-
  discourse:
    server               : # https://meta.discourse.org/t/embedding-discourse-comments-via-javascript/31963 , e.g.: meta.discourse.org
  facebook:
    # https://developers.facebook.com/docs/plugins/comments
    appid                :
    num_posts            : # 5 (default)
    colorscheme          : # &quot;light&quot; (default), &quot;dark&quot;
  utterances:
    theme                : # &quot;github-light&quot; (default), &quot;github-dark&quot;
    issue_term           : # &quot;pathname&quot; (default)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;저자-설정&quot;&gt;저자 설정&lt;/h4&gt;
&lt;p&gt;minimal-mistakes theme은 사이트 좌측 사이드바에 기본으로 사이트 저자 소개를 설정한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Site Author
author:
  name             : &quot;beomjo&quot;
  avatar           : &quot;/assets/images/bio-photo.jpg&quot;
  bio              : &quot;beomjo dev log 🧑‍💻&quot;
  location         : &quot;South Korea&quot;
  email            :
  links:
    - label: &quot;Email&quot;
      icon: &quot;fas fa-fw fa-envelope-square&quot;
      url: &quot;qjatjr1108@gmail.com&quot;
    - label: &quot;Blog&quot;
      icon: &quot;fas fa-fw fa-link&quot;
      url: &quot;https://beomseok95.tistory.com/&quot;
    - label: &quot;GitHub&quot;
      icon: &quot;fab fa-fw fa-github&quot;
      url: &quot;https://github.com/beomjo&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;저자-설정---footer&quot;&gt;저자 설정 - Footer&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Site Footer
footer:
  links:
    - label: &quot;GitHub&quot;
      icon: &quot;fab fa-fw fa-github&quot;
      url: &quot;https://github.com/beomjo&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;블로그-표시방법-설정&quot;&gt;블로그 표시방법 설정&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Outputting
permalink: /:categories/:title/
paginate: 5 # 첫 페이지에보여줄 최근 게시물 수를 지정
paginate_path: /page:num/
timezone: Asia/Seoul # https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;포스트-쓰기&quot;&gt;포스트 쓰기&lt;/h2&gt;
&lt;p&gt;포스트는 특정 제목으로 작성되어야 한다. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YYYY-MM-DD-{TITLE}.md&lt;/code&gt; 형식으로 파일명을 작성한다 . 
메타데이터를 위한 yaml 부분을 상단에작성하고, 본문을 위한 마크다운 부분을 그 아래에 작성한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
title: Jekyll, minimal-mistakes 테마를 적용하기
categories:
  - Blogs
tags:
  - Blog
  - Jekyll
  - minimal-mistakes
toc: true
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>beomjo</name></author><category term="Blogs" /><category term="Jekyll" /><category term="minimal-mistakes" /><summary type="html">설정 Github Pages 호스팅을 위해 ${GITHUB_ID}.github.io 라는 이름으로 리파지토리를 생성해야 한다 Gem을 이용해서 Jekyll 을 설치한다</summary></entry><entry><title type="html">BOJ 10799. 쇠막대기</title><link href="/boj/boj-10799/" rel="alternate" type="text/html" title="BOJ 10799. 쇠막대기" /><published>2021-02-09T00:00:00+09:00</published><updated>2021-02-09T00:00:00+09:00</updated><id>/boj/boj-10799</id><content type="html" xml:base="/boj/boj-10799/">&lt;h1 id=&quot;boj10799쇠막대기&quot;&gt;&lt;strong&gt;BOJ 10799. 쇠막대기&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812296-3db6e5cc-c4a6-4775-ba5c-eaec9beddac8.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812298-86f3d7b1-821c-47e9-86b4-f4386fbf3704.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812314-8f1e9fc9-e19d-4fa4-8b16-22e8314607c2.png&quot; alt=&quot;image&quot; /&gt;
레이저는 인접한 괄호쌍&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;로 표현한다.&lt;br /&gt;
쇠막대기의 왼쪽 끝은 여는 괄호&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt;, 오른쪽 끝은 닫는괄호&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;)&lt;/code&gt;로 표현한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여는 괄호&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt;를 만났을 때는 Stack에 넣어준다.&lt;/li&gt;
  &lt;li&gt;닫는 괄호 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;)&lt;/code&gt;를 만났을때
    &lt;ul&gt;
      &lt;li&gt;Stack.peak()가 여는괄호&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt;일 경우 Stack.pop() 한 후 남은 Stack의 size가 잘린 쇠막대기의 개수가 된다.&lt;/li&gt;
      &lt;li&gt;Stack.peak()가 닫는괄호&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;)&lt;/code&gt;일 경우 Stack.pop() 한 후 쇠막대기의 개수를 +1 한다
        &lt;ul&gt;
          &lt;li&gt;이때 쇠막대기의 마지막 이므로 이미 왼쪽에 생긴 쇠막대기는 모두 세었으니, 세지 못한 1개만 더한다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((()()))&lt;/code&gt;인 경우&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812324-5954e5aa-fc5e-4353-ab29-3e7bfa71330d.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812325-cc9a508f-f498-403c-9acc-c9e231474c0f.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812327-a6c2112f-0aa7-4865-acf2-65a382658d5e.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812329-87585b08-e390-4809-8f75-a063ec67f518.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.*;
import java.util.Stack;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = br.readLine();
        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        int t = 0;

        for (int i = 0; i &amp;lt; input.length(); i++) {
            char c = input.charAt(i);
            if (c == '(') {
                stack.push(c);
            } else {
                stack.pop();
                if (input.charAt(i - 1) == '(') {
                    t += stack.size();
                } else {
                    t++;
                }
            }
        }

        System.out.print(t);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.*

fun main() {
    val input = readLine()!!
    val stack = Stack&amp;lt;Char&amp;gt;()
    var t = 0
    var before = ' '
    input.forEach { c -&amp;gt;
        if (c == '(') stack.push(c)
        else {
            stack.pop()
            t += if (before == '(') stack.size else 1
        }
        before = c
    }
    println(t)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/java/10799.java&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/java/10799.java&lt;/a&gt;
&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/10799.kt&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/10799.kt&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 10799. 쇠막대기</summary></entry><entry><title type="html">BOJ 17289. 오큰수</title><link href="/boj/boj-17289/" rel="alternate" type="text/html" title="BOJ 17289. 오큰수" /><published>2021-02-09T00:00:00+09:00</published><updated>2021-02-09T00:00:00+09:00</updated><id>/boj/boj-17289</id><content type="html" xml:base="/boj/boj-17289/">&lt;h1 id=&quot;boj17298오큰수&quot;&gt;&lt;strong&gt;BOJ 17298. 오큰수&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812387-43552558-a687-4f46-b552-556fe944b3b0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;오큰수&lt;/strong&gt;란 입력된 숫자의 오른쪽에 있는 수들 중 가장 큰 수를 의미한다.  
입력이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3 5 2 7&lt;/code&gt; 일 때&lt;br /&gt;
입력 개수가 4개이므로 0부터 3까지 루프를 돌아준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i == 0&lt;/strong&gt; 일 때 &lt;br /&gt;
stack은 비어있으므로 stack.push&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812389-1c5d4a8c-cc13-4584-bc72-f059acea1358.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i == 1&lt;/strong&gt; 일때
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack.isNotEmpty &amp;amp;&amp;amp; number(5) &amp;gt; stack.peek().element(3)&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 이므로 &lt;br /&gt;
while문을 돌아 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;answer[0]&lt;/code&gt;에 5를 넣는다.&lt;/p&gt;

&lt;p&gt;그리고 stack에도 element:5, position 1을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812391-9c19348c-2020-466f-8508-f3c5175e48e9.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i == 2&lt;/strong&gt; 일 때 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack.isNotEmpty &amp;amp;&amp;amp; number(2) &amp;gt; stack.peek().element(5)&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 이므로 
while문을 돌지 않고 stack에 element:2 , position 2를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812394-e2adeec1-2490-45cf-bcff-bae58f3118d9.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i == 3&lt;/strong&gt;  일 때  
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack.isNotEmpty &amp;amp;&amp;amp; number(7) &amp;gt; stack.peek().element(2)&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 이므로 &lt;br /&gt;
while문을 돌아 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;answer[2]&lt;/code&gt;에 7을 넣는다.
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812396-9a72d59f-e2e5-406f-acf5-17d47721414c.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다시 while문을 돌아 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack.isNotEmpty &amp;amp;&amp;amp;  number(7) &amp;gt; stack.peek().element(5)&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 이므로 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;answer[1]&lt;/code&gt;에 7을 넣는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812405-b8569c39-b510-4247-bb06-24e779a37b91.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;for 루프를 모두 돌았으므로 &lt;br /&gt;
남은 answer에는 -1을 채운다.&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812417-8cf76693-5f33-4d88-a1be-2e711c827abe.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.*;
import java.util.Stack;
import java.util.StringTokenizer;

class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int N = Integer.parseInt(br.readLine());
        int[] answer = new int[N];
        StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;);
        Stack&amp;lt;NGE&amp;gt; s = new Stack&amp;lt;&amp;gt;();

        for (int i = 0; i &amp;lt; N; i++) {
            int number = Integer.parseInt(st.nextToken());
            while (!s.isEmpty() &amp;amp;&amp;amp; number &amp;gt; s.peek().element) {
                answer[s.pop().position] = number;
            }
            s.push(new NGE(number, i));
        }

        for (int r : answer) {
            if (r == 0) r = -1;
            bw.write(r+&quot; &quot;);
        }
        bw.flush();
    }
}

class NGE {
    int element, position;

    public NGE(int element, int position) {
        this.element = element;
        this.position = position;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.*

fun main() {
    val N = readLine()!!.toInt()
    val input = readLine()!!.split(&quot; &quot;).map { it.toInt() }
    val stack = Stack&amp;lt;NGE&amp;gt;()
    val answer = MutableList(N) { -1 }

    repeat(N) { i -&amp;gt;
        val number = input[i]
        while (!stack.isEmpty() &amp;amp;&amp;amp; number &amp;gt; stack.peek().element) {
            answer[stack.pop().position] = number
        }
        stack.push(NGE(number, i))
    }

    print(answer.joinToString(&quot; &quot;))
}

data class NGE(
    val element: Int,
    val position: Int,
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/java/17298.java&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/java/17298.java&lt;/a&gt;
&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/17298.kt&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/17298.kt&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 17298. 오큰수</summary></entry><entry><title type="html">BOJ 2609. 최대공약수와 최소공배수</title><link href="/boj/boj-2609/" rel="alternate" type="text/html" title="BOJ 2609. 최대공약수와 최소공배수" /><published>2021-02-09T00:00:00+09:00</published><updated>2021-02-09T00:00:00+09:00</updated><id>/boj/boj-2609</id><content type="html" xml:base="/boj/boj-2609/">&lt;h1 id=&quot;boj2609최대공약수와최소공배수&quot;&gt;&lt;strong&gt;BOJ 2609. 최대공약수와 최소공배수&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812720-fd59b3e8-a904-454a-943e-025d9f47c0a7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;최대-공약수를-구하는-방법-1&quot;&gt;&lt;strong&gt;최대 공약수를 구하는 방법 1&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int getGCP(int a, int b) {
    int r = 1;
    for (int i = 2; i &amp;lt; Math.min(a, b); i++) {
        if (a % i == 0 &amp;amp;&amp;amp; b % i == 0) {
            r = i;
        }
    }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;2부터 a와 b 중 작은 값 까지&lt;br /&gt;
a와 b 모두 나머지가 0인 수를 찾기&lt;/p&gt;

&lt;h3 id=&quot;최대-공약수를-구하는-방법-2&quot;&gt;&lt;strong&gt;최대 공약수를 구하는 방법 2&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;유클리드 호제법을 재귀 함수를 통해 구현&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int getGCP(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return getGCP(b, a % b);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812726-7e96a369-46db-4579-8403-0375e61289a7.png&quot; alt=&quot;image&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812727-f5b99a71-a5d3-4fd3-b8d5-9633f2b38c3e.png&quot; alt=&quot;image&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812730-c9a7ad37-de96-48ae-a2d1-09509cd658f3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;최대-공약수를-구하는-방법-3&quot;&gt;&lt;strong&gt;최대 공약수를 구하는 방법 3&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;유클리드 호제법 while문 사용하여 구현&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  int getGCP(int a, int b) {
        while (b != 0) {
            int r = a % b;
            a = b;
            b = r;
        }
        return a;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;java&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.*;
import java.util.Scanner;

class Main {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();

        int gcp = getGCP(a, b);
        int lcm = getLCM(a, b, gcp);

        System.out.println(gcp);
        System.out.println(lcm);
        sc.close();
    }

    static int getGCP(int a, int b) {
        int r = 1;
        for (int i = 2; i &amp;lt; Math.min(a, b); i++) {
            if (a % i == 0 &amp;amp;&amp;amp; b % i == 0) {
                r = i;
            }
        }
        return r;
    }

    static int getLCM(int a, int b, int gcp) {
        return a * b / gcp;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;kotlin&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.*

fun getGCP(a: Int, b: Int): Int = if (b == 0) a else getGCP(b, a % b)
fun getLCM(a: Int, b: Int): Int = a * b / getGCP(a, b)

fun main() {
    val sc = Scanner(System.`in`)
    val a = sc.nextInt()
    val b = sc.nextInt()

    val gcp = getGCP(a, b)
    val lcm = getLCM(a, b)

    println(gcp)
    println(lcm)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;소스풀이&quot;&gt;소스풀이&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/java/2609.java&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/java/2609.java&lt;/a&gt;
&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/2609.kt&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/2609.kt&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 2609. 최대공약수와 최소공배수</summary></entry><entry><title type="html">BOJ 17413. 단어뒤집기2</title><link href="/boj/boj-17413/" rel="alternate" type="text/html" title="BOJ 17413. 단어뒤집기2" /><published>2021-02-09T00:00:00+09:00</published><updated>2021-02-09T00:00:00+09:00</updated><id>/boj/boj-17413</id><content type="html" xml:base="/boj/boj-17413/">&lt;h1 id=&quot;boj17413단어-뒤집기2&quot;&gt;BOJ 17413. 단어 뒤집기 2&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812224-e189983e-5a20-4766-a018-227e0c30d71b.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812240-6d43f5dd-f321-4178-968f-38542879a2ed.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;단어를 뒤집는 방법은 Stack에 순서대로 push 하고 다시 pop 하여 단어를 뒤집는다.&lt;br /&gt;
태그 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; or&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;' '&lt;/code&gt;or&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'\n'&lt;/code&gt;를 만나면 만나면 이전까지 Stack에 쌓아놓은 단어들을 모두 pop 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.*;
import java.util.Stack;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        String input = br.readLine() + &quot;\n&quot;;

        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();

        boolean isTag = false;

        for (int i = 0; i &amp;lt; input.length(); i++) {
            char c = input.charAt(i);

            if (c == '&amp;lt;') isTag = true;
            if (isTag || c == ' ' || c == '\n') {
                while (!stack.isEmpty()) {
                    bw.write(stack.pop());
                }
                if (c != '\n') bw.write(c);
            } else {
                stack.push(c);
            }
            if (c == '&amp;gt;') isTag = false;
        }
        bw.flush();
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.lang.StringBuilder
import java.util.*

fun main() {
    val stack = Stack&amp;lt;Char&amp;gt;()
    val sb = StringBuilder()
    var isTag = false
    &quot;${readLine()!!}\n&quot;.forEach { c -&amp;gt;
        if (c == '&amp;lt;') isTag = true
        if (isTag || c == ' ' || c == '\n') {
            while (!stack.isEmpty()) {
                sb.append(stack.pop())
            }
            if (c != '\n') sb.append(c)
        } else {
            stack.push(c);
        }
        if (c == '&amp;gt;') isTag = false
    }
    print(sb)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/java/17413.java&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/java/17413.java&lt;/a&gt;
&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/17413.kt&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/17413.kt&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 17413. 단어 뒤집기 2</summary></entry><entry><title type="html">BOJ 1157. 요세푸스 문제</title><link href="/boj/boj-1158/" rel="alternate" type="text/html" title="BOJ 1157. 요세푸스 문제" /><published>2021-02-01T00:00:00+09:00</published><updated>2021-02-01T00:00:00+09:00</updated><id>/boj/boj-1158</id><content type="html" xml:base="/boj/boj-1158/">&lt;h1 id=&quot;boj1158요세푸스문제&quot;&gt;&lt;strong&gt;BOJ 1158. 요세푸스 문제&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812080-9c92b5e8-fa3d-41a3-baaf-6d782267000c.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;큐를 이용하여 요세푸스 순열을 만든다.&lt;br /&gt;
먼저 입력으로 N=7이 들어왔을 때 초기 상태로 1부터 7까지 큐에 넣는다.&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812084-28a1335a-92ce-4b1e-a0c7-0ffb1270e6aa.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 다음  K=3이므로 3번째 사람을 제거해야 하므로&lt;br /&gt;
큐에서 순서대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;poll()&lt;/code&gt; 한 뒤 다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offer()&lt;/code&gt;로 큐에 넣어준다.&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812086-5cb63493-202e-4e79-ab19-a2c5f47d044a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 3번째가 되었을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;poll()&lt;/code&gt; 한뒤 다시 큐에 넣지 않고 출력 버퍼에 저장한다.&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812091-4941c390-3746-44f3-9d63-640d937e2fd5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다시 반복하여 2번 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;poll()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offer()&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812096-dbfa9be6-90bb-4ee0-8983-ac383087af0c.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3번째가 되었을 때 또다시 큐에 넣지 않고 출력 버퍼에 저장&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134812101-d1aa9cbc-d590-459d-95b5-5347764afb72.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;계속 반복하여 순열을 완성한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.*;
import java.util.LinkedList;
import java.util.Queue;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(&quot; &quot;);
        int n = Integer.parseInt(input[0]);
        int k = Integer.parseInt(input[1]);

        Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        for (int i = 1; i &amp;lt;= n; i++) {
            queue.offer(i);
        }

        StringBuilder sb = new StringBuilder();

        sb.append(&quot;&amp;lt;&quot;);
        while (queue.size() &amp;gt; 1) {
            for (int j = 1; j &amp;lt; k; j++) {
                queue.offer(queue.poll());
            }

            sb.append(queue.poll()).append(&quot;, &quot;);
        }
        sb.append(queue.poll()).append(&quot;&amp;gt;&quot;);
        System.out.print(sb);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.*

fun main () {
    val scanner = Scanner(System.`in`)
    val n = scanner.nextInt()
    val k = scanner.nextInt()

    val queue = LinkedList((1..n).toMutableList())

    print(&quot;&amp;lt;&quot;)
    while (queue.size &amp;gt; 1) {
        repeat((1 until k).count()) { queue.add(queue.pop()) }
        print(&quot;${queue.pop()}, &quot;)
    }
    print(&quot;${queue.remove()}&amp;gt;&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/java/1158.java&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/java/1158.java&lt;/a&gt;
&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/1158.kt&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/1158.kt&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 1158. 요세푸스 문제</summary></entry><entry><title type="html">BOJ 1406. 에디터</title><link href="/boj/boj-1406/" rel="alternate" type="text/html" title="BOJ 1406. 에디터" /><published>2021-02-01T00:00:00+09:00</published><updated>2021-02-01T00:00:00+09:00</updated><id>/boj/boj-1406</id><content type="html" xml:base="/boj/boj-1406/">&lt;h1 id=&quot;boj1406에디터&quot;&gt;&lt;strong&gt;BOJ 1406. 에디터&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134811823-74ded316-1bd7-4f9c-80aa-5d7305a75b33.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134811829-e9bd4fb6-19ac-493b-89b3-99c7c99e913d.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;커서의 왼쪽과 오른쪽에 각각 Stack으로 관리한다.&lt;br /&gt;
먼저 커서는 입력 문장의 끝에 위치하므로  
커서 왼쪽 스택에 입력문장을 모두 넣고 시작한다.&lt;/p&gt;

&lt;p&gt;입력문자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abcd&lt;/code&gt;  
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134811877-a7ba12c6-c3ad-4724-b078-3baae3490ca8.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P x&lt;/code&gt;를 수행한다.&lt;br /&gt;
왼쪽 스택에 x를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt;한다.&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134811880-cedd0695-1e76-415b-87b1-f9a10a339512.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L&lt;/code&gt; 명령을 수행한다.&lt;br /&gt;
왼쪽으로 커서를 한 칸 이동하게 되므로&lt;br /&gt;
왼쪽 스택에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt;, 오른쪽으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134811883-144816c0-4fcc-4e44-a705-06f29b5c1f24.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P y&lt;/code&gt;를 수행한다.&lt;br /&gt;
왼쪽 스택에 y를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt;한다.&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134811886-e931acc1-7d3c-4281-bdab-806ff32cf7f4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 다음 출력을 위해 오른쪽 스택으로 모두 이동&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134811888-fcc29116-8de1-483c-8ae7-75a8b04ac7f8.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오른쪽 스택에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt; 하여 순서대로 출력&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.*;
import java.util.Stack;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();
        int t = Integer.parseInt(br.readLine());
        Stack&amp;lt;Character&amp;gt; leftStack = new Stack&amp;lt;&amp;gt;();
        Stack&amp;lt;Character&amp;gt; rightStack = new Stack&amp;lt;&amp;gt;();
        
        for (int i = 0; i &amp;lt; str.length(); i++) {
            leftStack.push(str.charAt(i));
        }

        while (t-- &amp;gt; 0) {
            String input = br.readLine();
            String[] inputs = input.split(&quot; &quot;);
            if (&quot;L&quot;.equals(inputs[0])) {
                if (leftStack.size() &amp;gt; 0) {
                    Character c = leftStack.pop();
                    rightStack.push(c);
                }
            } else if (&quot;D&quot;.equals(inputs[0])) {
                if (rightStack.size() &amp;gt; 0) {
                    Character c = rightStack.pop();
                    leftStack.push(c);
                }
            } else if (&quot;B&quot;.equals(inputs[0])) {
                if (leftStack.size() &amp;gt; 0) {
                    leftStack.pop();
                }
            } else {
                leftStack.push(inputs[1].charAt(0));
            }
        }

        StringBuilder sb = new StringBuilder();
        while (!leftStack.isEmpty()) {
            rightStack.push(leftStack.pop());
        }

        while (!rightStack.isEmpty()) {
            sb.append(rightStack.pop());
        }

        System.out.print(sb);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코틀린 풀이에서는 &lt;/p&gt;

&lt;p&gt;커서 왼쪽은 Stack 오른쪽은 LinkedList를 이용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main() {
    val str = readLine()!!
    val t = readLine()!!.toInt()

    val st = Stack&amp;lt;Char&amp;gt;()
    val q = LinkedList&amp;lt;Char&amp;gt;()

    for (ch in str) {
        st.push(ch)
    }

    repeat(t) {
        when (val input = readLine()!!) {
            &quot;L&quot; -&amp;gt; if (!st.isEmpty()) q.addFirst(st.pop())
            &quot;D&quot; -&amp;gt; if (!q.isEmpty()) st.push(q.poll())
            &quot;B&quot; -&amp;gt; if (!st.isEmpty()) st.pop()
            else -&amp;gt; st.push(input.split(&quot; &quot;)[1][0])
        }
    }
    println(&quot;${st.joinToString(&quot;&quot;)}${q.joinToString(&quot;&quot;)}&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/java/1406.java&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/java/1406.java&lt;/a&gt;
&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/1406.kt&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/1406.kt&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 1406. 에디터</summary></entry><entry><title type="html">BOJ 1874. 스택수열</title><link href="/boj/boj-1874/" rel="alternate" type="text/html" title="BOJ 1874. 스택수열" /><published>2021-02-01T00:00:00+09:00</published><updated>2021-02-01T00:00:00+09:00</updated><id>/boj/boj-1874</id><content type="html" xml:base="/boj/boj-1874/">&lt;h1 id=&quot;boj-1874-스택-수열&quot;&gt;&lt;strong&gt;BOJ 1874. 스택 수열&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134807944-b729b1d3-f874-4571-b8a6-dcc81ed99389.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134807958-7dbfe12b-0611-44bd-b9f5-46b40999aaf8.png&quot; alt=&quot;image&quot; /&gt;
​&lt;/p&gt;
&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;입력으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4 3 6 8 7 5 2 1&lt;/code&gt;으로 주어졌을 때 &lt;br /&gt;
먼저 1부터 시작하여 4까지 Stack에 순서대로 push(+)한다.
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134807961-a882cbd5-2a36-4408-8569-d91a81d63a66.png&quot; alt=&quot;image&quot; /&gt;&lt;br /&gt;
​
입력인 4가 되었을 때 Stack에서 pop(-)&lt;br /&gt;
또 다음 입력인 3이 되었을 때 Stack에서 pop(-)한다.&lt;br /&gt;
​&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134807983-9c4f22dc-6bfe-4303-9d50-98fc9f947f55.png&quot; alt=&quot;image&quot; /&gt;&lt;br /&gt;
​
다음 입력인 6이 될 때까지 Stack에 다시 push(+)&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134807998-ab2f82e5-ae36-4f1e-8af6-220e1b81a2ac.png&quot; alt=&quot;image&quot; /&gt;
​
입력인 6에 도달하였으니 pop(-) &lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134808026-83a16014-ac3d-4199-bbc0-74544130df82.png&quot; alt=&quot;image&quot; /&gt;
​
위와 같이 반복한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.*;
import java.util.Stack;
​
class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        int total = Integer.parseInt(br.readLine());
        int i = 1;
        while (total-- &amp;gt; 0) {
            int input = Integer.parseInt(br.readLine());
            while (i &amp;lt;= input) {
                stack.push(i);
                sb.append(&quot;+\n&quot;);
                i++;
            }
​
            if (stack.peek() == input) {
                stack.pop();
                sb.append(&quot;-\n&quot;);
            } else {
                System.out.print(&quot;NO&quot;);
                return;
            }
        }
        System.out.println(sb);
        br.close();
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.lang.StringBuilder
import java.util.*
​
fun main() {
    val stack = Stack&amp;lt;Int&amp;gt;()
    val sb = StringBuilder()
    var i = 1;
    repeat(readLine()?.toInt() ?: return) {
        val input = readLine()!!.toInt()
        while (i &amp;lt;= input) {
            stack.push(i)
            sb.append(&quot;+\n&quot;)
            i++
        }
        if (stack.peek() == input) {
            stack.pop()
            sb.append(&quot;-\n&quot;)
        } else {
            print(&quot;NO&quot;)
            return
        }
    }
    println(sb)
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h2 id=&quot;풀이-소스&quot;&gt;풀이 소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/java/1874.java&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/java/1874.java&lt;/a&gt;
&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/1874.kt&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/1874.kt&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 1874. 스택 수열 ​ 풀이 입력으로 4 3 6 8 7 5 2 1으로 주어졌을 때 먼저 1부터 시작하여 4까지 Stack에 순서대로 push(+)한다. ​ 입력인 4가 되었을 때 Stack에서 pop(-) 또 다음 입력인 3이 되었을 때 Stack에서 pop(-)한다. ​ ​ 다음 입력인 6이 될 때까지 Stack에 다시 push(+) ​ 입력인 6에 도달하였으니 pop(-) ​ 위와 같이 반복한다. import java.io.*; import java.util.Stack; ​ class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); int total = Integer.parseInt(br.readLine()); int i = 1; while (total-- &amp;gt; 0) { int input = Integer.parseInt(br.readLine()); while (i &amp;lt;= input) { stack.push(i); sb.append(&quot;+\n&quot;); i++; } ​ if (stack.peek() == input) { stack.pop(); sb.append(&quot;-\n&quot;); } else { System.out.print(&quot;NO&quot;); return; } } System.out.println(sb); br.close(); return; } } ​ import java.lang.StringBuilder import java.util.* ​ fun main() { val stack = Stack&amp;lt;Int&amp;gt;() val sb = StringBuilder() var i = 1; repeat(readLine()?.toInt() ?: return) { val input = readLine()!!.toInt() while (i &amp;lt;= input) { stack.push(i) sb.append(&quot;+\n&quot;) i++ } if (stack.peek() == input) { stack.pop() sb.append(&quot;-\n&quot;) } else { print(&quot;NO&quot;) return } } println(sb) return } ​ 풀이 소스 github.com/beomjo/algorithm-study/blob/main/BOJ/java/1874.java github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/1874.kt</summary></entry><entry><title type="html">BOJ 9012. 괄호</title><link href="/boj/boj-9012/" rel="alternate" type="text/html" title="BOJ 9012. 괄호" /><published>2021-01-20T00:00:00+09:00</published><updated>2021-01-20T00:00:00+09:00</updated><id>/boj/boj-9012</id><content type="html" xml:base="/boj/boj-9012/">&lt;h2 id=&quot;boj9012괄호&quot;&gt;&lt;strong&gt;BOJ 9012. 괄호&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;문제&quot;&gt;&lt;strong&gt;문제&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;)&lt;/code&gt; 만으로 구성되어 있는 문자열이다. 그중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. &lt;br /&gt;
한 쌍의 괄호 기호로 된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;( )&lt;/code&gt; 문자열은 기본 VPS이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x)&lt;/code&gt;도 VPS 가 된다. 그리고 두 VPS x와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. &lt;br /&gt;
예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(())()&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((()))&lt;/code&gt; 는 VPS이지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(()(”, “(())()))&lt;/code&gt; , 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(()&lt;/code&gt; 는 모두 VPS 가 아닌 문자열이다. &lt;/p&gt;

&lt;p&gt;여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO로 나타내어야 한다. &lt;/p&gt;

&lt;h3 id=&quot;입력&quot;&gt;&lt;strong&gt;입력&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다. &lt;/p&gt;

&lt;h3 id=&quot;출력&quot;&gt;&lt;strong&gt;출력&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다. &lt;/p&gt;

&lt;h3 id=&quot;예제입력1&quot;&gt;&lt;strong&gt;예제 입력 1&lt;/strong&gt; &lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6
(())())
(((()())()
(()())((()))
((()()(()))(((())))()
()()()()(()()())()
(()((())()(
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;예제출력1&quot;&gt;&lt;strong&gt;예제 출력 1&lt;/strong&gt; &lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NO
NO
YES
NO
YES
NO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;예제입력2&quot;&gt;&lt;strong&gt;예제 입력 2&lt;/strong&gt; &lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3
((
))
())(()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;예제출력2&quot;&gt;&lt;strong&gt;예제 출력 2&lt;/strong&gt; &lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NO
NO
NO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Stack을 이용하여 올바른 괄호 문자열인지 판한단다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt; 가 나오면 스택에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt;를 넣는다&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;)&lt;/code&gt; 가 나오면 스택에서 하나를 뺄 수 있는지 확인하여 뺀다
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Main {
  public static void main(String[] args) throws IOException {
      BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
      int total = Integer.parseInt(bufferedReader.readLine());
      BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(System.out));

      while (total-- &amp;gt; 0) {
          Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
          String input = bufferedReader.readLine();
          boolean isVPS = true;
          for (int i = 0; i &amp;lt; input.length(); i++) {
              char c = input.charAt(i);
              if (c == '(') {
                  stack.push(c);
              } else {
                  if (!stack.isEmpty()) {
                      stack.pop();
                  } else {
                      isVPS = false;
                      break;
                  }
              }
          }
          if (!stack.isEmpty()) {
              isVPS = false;
          }

          bufferedWriter.write(isVPS ? &quot;YES\n&quot; : &quot;NO\n&quot;);
      }
      bufferedWriter.flush();
      return;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;코틀린 풀이&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main() {
    repeat(readLine()?.toInt() ?: return) {
        var prev = readLine()!!
        var curr = prev.replace(&quot;()&quot;, &quot;&quot;)

        while (prev != curr) {
            prev = curr
            curr = curr.replace(&quot;()&quot;, &quot;&quot;)
        }
        println(if (curr.isEmpty()) &quot;YES&quot; else &quot;NO&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 9012. 괄호</summary></entry><entry><title type="html">BOJ 9093. 단어 뒤집기</title><link href="/boj/boj-9093/" rel="alternate" type="text/html" title="BOJ 9093. 단어 뒤집기" /><published>2021-01-19T00:00:00+09:00</published><updated>2021-01-19T00:00:00+09:00</updated><id>/boj/boj-9093</id><content type="html" xml:base="/boj/boj-9093/">&lt;h1 id=&quot;boj-9093-단어-뒤집기&quot;&gt;BOJ 9093. 단어 뒤집기&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9093&quot;&gt;www.acmicpc.net/problem/9093&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;strong&gt;문제&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;문장이 주어졌을 때, 단어를 모두 뒤집어서 출력하는 프로그램을 작성하시오. &lt;br /&gt;
단, 단어의 순서는 바꿀 수 없다. &lt;br /&gt;
단어는 영어 알파벳으로만 이루어져 있다.&lt;/p&gt;

&lt;h2 id=&quot;입력&quot;&gt;&lt;strong&gt;입력&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;첫째 줄에 테스트 케이스의 개수 T가 주어진다. &lt;br /&gt;
각 테스트 케이스는 한 줄로 이루어져 있으며, 문장이 하나 주어진다. &lt;br /&gt;
단어의 길이는 최대 20, 문장의 길이는 최대 1000이다. &lt;br /&gt;
단어와 단어 사이에는 공백이 하나 있다.&lt;/p&gt;

&lt;h2 id=&quot;출력&quot;&gt;&lt;strong&gt;출력&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;각 테스트 케이스에 대해서, 입력으로 주어진 문장의 단어를 모두 뒤집어 출력한다.&lt;/p&gt;

&lt;h2 id=&quot;예제입력1&quot;&gt;&lt;strong&gt;예제 입력 1&lt;/strong&gt; &lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2
I am happy today
We want to win the first prize
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;예제-출력-1&quot;&gt;&lt;strong&gt;예제 출력 1&lt;/strong&gt; &lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I ma yppah yadot
eW tnaw ot niw eht tsrif ezirp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;N개의 글자를 스택에 넣었다가 빼면 순서가 역순이 된다&lt;/li&gt;
  &lt;li&gt;알파벳을 스택에 넣고, 공백이나 문자열의 끝이면 스택에서 모두 빼내서 역순으로 만든다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.Scanner;
import java.util.Stack;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int t = sc.nextInt();
        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        sc.nextLine(); //sc.nextInt() 후에 \n이 남아있어서 Clear

        while (t-- &amp;gt; 0) {
            String input = sc.nextLine() + &quot; &quot;;
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i &amp;lt; input.length(); i++) {
                char c = input.charAt(i);
                if (c == ' ') {
                    while (!stack.isEmpty()) {
                        sb.append(stack.pop());
                    }
                    sb.append(&quot; &quot;);
                } else {
                    stack.push(c);
                }
            }
            System.out.println(sb.toString());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Scanner의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextInt()&lt;/code&gt; 메서드는 입력의 가장 마지막 개행 문자(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\n&lt;/code&gt;)를 제거하지 않아  
바로 다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextLine()&lt;/code&gt;을 호출하면 제대로 문자열을 입력받지 못하는 문제가 있다.&lt;br /&gt;
BufferedReader를 사용하여보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.*;
import java.util.Stack;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bf.readLine());
        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;Character&amp;gt;();
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        while (num-- &amp;gt; 0) {
            String input = bf.readLine() + &quot;\n&quot;;
            for (char ch : input.toCharArray()) {
                if (ch == ' ' || ch == '\n') {
                    while (!stack.isEmpty()) {
                        bw.write(stack.pop());
                    }
                    bw.write(ch); // 공백
                } else
                    stack.push(ch);
            }
        }
        bw.flush();
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Scanner는 space와 개행 문자(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\n&lt;/code&gt;)를 경계로 인식하여 구분하는 반면&lt;br /&gt;
BufferedReader는 개행 문자(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\n&lt;/code&gt;)만으로 경계를 구분하고 문자열만을 읽는다.&lt;/p&gt;

&lt;p&gt;또한 Scanner에 비하여 상대적으로 빠른 속도의 장점이 있다.&lt;/p&gt;

&lt;p&gt;Kotlin으로 작성하면 Stack을 사용하지 않고  &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;split()&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;joinToString()&lt;/code&gt; 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reversed()&lt;/code&gt; 함수를 사용하여 작성할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))
    var t = br.readLine().toInt()

    while(t-- &amp;gt; 0) {
        val input = br.readLine().split(&quot; &quot;)
        println(input.joinToString(&quot; &quot;) { it.reversed() })
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/java/9093.java&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/java/9093.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/9093.kt&quot;&gt;github.com/beomjo/algorithm-study/blob/main/BOJ/kotlin/9093.kt&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 9093. 단어 뒤집기 www.acmicpc.net/problem/9093</summary></entry></feed>