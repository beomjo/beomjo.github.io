<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-09-27T01:09:51+09:00</updated><id>/feed.xml</id><title type="html">Beom Log</title><subtitle>beomjo amazing website.</subtitle><author><name>beomjo</name></author><entry><title type="html">Jekyll, minimal-mistakes 테마를 적용하기</title><link href="/blogs/create-blog/" rel="alternate" type="text/html" title="Jekyll, minimal-mistakes 테마를 적용하기" /><published>2021-06-29T00:00:00+09:00</published><updated>2021-06-29T00:00:00+09:00</updated><id>/blogs/create-blog</id><content type="html" xml:base="/blogs/create-blog/">&lt;h2 id=&quot;설정&quot;&gt;설정&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Github Pages 호스팅을 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;${GITHUB_ID}.github.io&lt;/code&gt; 라는 이름으로 리파지토리를 생성해야 한다&lt;/li&gt;
  &lt;li&gt;Gem을 이용해서 Jekyll 을 설치한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;테마-적용&quot;&gt;테마 적용&lt;/h2&gt;
&lt;p&gt;minimal-mistake &lt;a href=&quot;https://mmistakes.github.io/minimal-mistakes/docs/quick-start-guide/&quot;&gt;빠른 시작 가이드&lt;/a&gt;를 참고하여 진행한다.&lt;br /&gt;
&lt;a href=&quot;https://github.com/mmistakes/minimal-mistakes&quot;&gt;minimal-mistake&lt;/a&gt; Repository에서 소스를 가져와 옮긴다.&lt;br /&gt;
옮긴 후 다음 과정을 진행한다.&lt;/p&gt;

&lt;h3 id=&quot;불필요-내용-제거&quot;&gt;불필요 내용 제거&lt;/h3&gt;
&lt;p&gt;minimal-mistakes-jekyll repository에서 소스를 가져왔다면 불필요한 내용을 제거한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;.editorconfig&lt;/li&gt;
  &lt;li&gt;.gitattributes&lt;/li&gt;
  &lt;li&gt;.github&lt;/li&gt;
  &lt;li&gt;/docs&lt;/li&gt;
  &lt;li&gt;/test&lt;/li&gt;
  &lt;li&gt;CHANGELOG.md&lt;/li&gt;
  &lt;li&gt;minimal-mistakes-jekyll.gemspec&lt;/li&gt;
  &lt;li&gt;README.md&lt;/li&gt;
  &lt;li&gt;screenshot-layouts.png&lt;/li&gt;
  &lt;li&gt;screenshot.png&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;_config-파일-설정&quot;&gt;_config 파일 설정&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yaml&lt;/code&gt; 파일에서 아래와 값들을 설정해준다&lt;/p&gt;

&lt;h4 id=&quot;기본-구성&quot;&gt;기본 구성&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Site Settings
minimal_mistakes_skin    : &quot;dark&quot;
title                    : &quot;Beom Log&quot;
name                     : &quot;취미코딩하는 개발자&quot;
description              : &quot;회사에서는 월급 받고 집에서는 취미로 코딩하는 개발자의 블로그&quot;
url                      : &quot;https://beomjo.github.io&quot;
baseurl                  : # 서브 경로가 있는 경우 기재
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;teaser와-logo-그림-파일&quot;&gt;teaser와 logo 그림 파일&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;teaser                   : &quot;/assets/images/bio.jpg&quot;
logo                     : # 최상단 메뉴 바에 사이트 로고 넣기
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;댓글&quot;&gt;댓글&lt;/h4&gt;
&lt;p&gt;블로그 댓글 기능 disqus, discourse, facebook, staticman, utterances 정도가 대표적이다. &lt;br /&gt;
GitHub Pages 자체적으로 댓글을 제공하고 있지 않기때문에 보통 외부 댓글 서비스를 연결해주는 방식을 사용한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;comments:
  provider               : # 블로그 댓글 기능 false (default), &quot;disqus&quot;, &quot;discourse&quot;, &quot;facebook&quot;, &quot;staticman&quot;, &quot;staticman_v2&quot;, &quot;utterances&quot;, &quot;custom&quot;
  disqus:
    shortname            : # 블로그 댓글 기능 https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-
  discourse:
    server               : # https://meta.discourse.org/t/embedding-discourse-comments-via-javascript/31963 , e.g.: meta.discourse.org
  facebook:
    # https://developers.facebook.com/docs/plugins/comments
    appid                :
    num_posts            : # 5 (default)
    colorscheme          : # &quot;light&quot; (default), &quot;dark&quot;
  utterances:
    theme                : # &quot;github-light&quot; (default), &quot;github-dark&quot;
    issue_term           : # &quot;pathname&quot; (default)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;저자-설정&quot;&gt;저자 설정&lt;/h4&gt;
&lt;p&gt;minimal-mistakes theme은 사이트 좌측 사이드바에 기본으로 사이트 저자 소개를 설정한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Site Author
author:
  name             : &quot;beomjo&quot;
  avatar           : &quot;/assets/images/bio-photo.jpg&quot;
  bio              : &quot;beomjo dev log 🧑‍💻&quot;
  location         : &quot;South Korea&quot;
  email            :
  links:
    - label: &quot;Email&quot;
      icon: &quot;fas fa-fw fa-envelope-square&quot;
      url: &quot;qjatjr1108@gmail.com&quot;
    - label: &quot;Blog&quot;
      icon: &quot;fas fa-fw fa-link&quot;
      url: &quot;https://beomseok95.tistory.com/&quot;
    - label: &quot;GitHub&quot;
      icon: &quot;fab fa-fw fa-github&quot;
      url: &quot;https://github.com/beomjo&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;저자-설정---footer&quot;&gt;저자 설정 - Footer&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Site Footer
footer:
  links:
    - label: &quot;GitHub&quot;
      icon: &quot;fab fa-fw fa-github&quot;
      url: &quot;https://github.com/beomjo&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;블로그-표시방법-설정&quot;&gt;블로그 표시방법 설정&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Outputting
permalink: /:categories/:title/
paginate: 5 # 첫 페이지에보여줄 최근 게시물 수를 지정
paginate_path: /page:num/
timezone: Asia/Seoul # https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;포스트-쓰기&quot;&gt;포스트 쓰기&lt;/h2&gt;
&lt;p&gt;포스트는 특정 제목으로 작성되어야 한다. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YYYY-MM-DD-{TITLE}.md&lt;/code&gt; 형식으로 파일명을 작성한다 . 
메타데이터를 위한 yaml 부분을 상단에작성하고, 본문을 위한 마크다운 부분을 그 아래에 작성한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
title: Jekyll, minimal-mistakes 테마를 적용하기
categories:
  - Blogs
tags:
  - Blog
  - Jekyll
  - minimal-mistakes
toc: true
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>beomjo</name></author><category term="Blogs" /><category term="Jekyll" /><category term="minimal-mistakes" /><summary type="html">설정 Github Pages 호스팅을 위해 ${GITHUB_ID}.github.io 라는 이름으로 리파지토리를 생성해야 한다 Gem을 이용해서 Jekyll 을 설치한다</summary></entry><entry><title type="html">BOJ 3085. 사탕게임</title><link href="/boj/boj-3085/" rel="alternate" type="text/html" title="BOJ 3085. 사탕게임" /><published>2021-03-17T00:00:00+09:00</published><updated>2021-03-17T00:00:00+09:00</updated><id>/boj/boj-3085</id><content type="html" xml:base="/boj/boj-3085/">&lt;h1 id=&quot;boj3085사탕게임&quot;&gt;&lt;strong&gt;BOJ 3085. 사탕게임&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134815428-62321a3d-324d-4498-b330-a79cd7fdd101.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;NxN 크기의 보드에서 두 칸을 골라 서로 사탕을 교환하고 &lt;br /&gt;
이때 인접해있는 사탕을 먹는다고 하였을 때  &lt;br /&gt;
먹을 수 있는 사탕의 최대 개수를 구하는 방법은&lt;/p&gt;

&lt;p&gt;보드 전체를 1번씩 확인해보아야 하는데, 아래와 오른쪽을 바꾸어가며 전체 보드를 확인해보면&lt;br /&gt;
보드를 모두 1번씩 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134815431-49394187-8d19-43f0-81fe-0406b90e1d12.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이때 시간 복잡도는 O(N&lt;em&gt;N)이다.&lt;br /&gt;
최대 주어지는 N의 수는 50이므로 50&lt;/em&gt;50은 &lt;br /&gt;
1초 안에 수행할 수 있는 경우의 수이므로 모든 경우의 수에 대입하여 정답을 찾아보도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swap()&lt;/code&gt;하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check()&lt;/code&gt;하여 인접한 사탕의 최대 개수를 구한 후 다시 원래대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swap()&lt;/code&gt; 해준다.&lt;/p&gt;

&lt;p&gt;이 과정을 반복하여 최대 개수를 구한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Main {
    static Character[][] a;
    static int N;
    static int ans = 0;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        N = Integer.parseInt(br.readLine());
        a = new Character[N][N];

        for (int i = 0; i &amp;lt; N; i++) {
            String input = br.readLine();
            for (int j = 0; j &amp;lt; N; j++) {
                a[i][j] = input.charAt(j);
            }
        }
        br.close();


        for (int i = 0; i &amp;lt; N; i++) {
            for (int j = 0; j &amp;lt; N; j++) {
                if (j + 1 &amp;lt; N) {
                    swap(i, j, i, j + 1);
                    check();
                    swap(i, j, i, j + 1);
                }

                if (i + 1 &amp;lt; N) {
                    swap(i, j, i + 1, j);
                    check();
                    swap(i, j, i + 1, j);
                }
            }
        }

        System.out.println(ans);
    }

    static void swap(int startI, int startJ, int endI, int endJ) {
        char temp = a[startI][startJ];
        a[startI][startJ] = a[endI][endJ];
        a[endI][endJ] = temp;
    }

    static void check() {
        for (int i = 0; i &amp;lt; N; i++) {
            int count = 1;
            for (int j = 0; j &amp;lt; N - 1; j++) {
                if (a[i][j] == a[i][j + 1]) {
                    count++;
                } else {
                    ans = Math.max(ans, count);
                    count = 1;
                }
            }
            ans = Math.max(ans, count);
        }

        for (int j = 0; j &amp;lt; N; j++) {
            int count = 1;
            for (int i = 0; i &amp;lt; N - 1; i++) {
                if (a[i][j] == a[i + 1][j]) {
                    count++;
                } else {
                    ans = Math.max(ans, count);
                    count = 1;
                }
            }
            ans = Math.max(ans, count);
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import kotlin.math.max

fun main() {
    val n = readLine()!!.toInt()
    val a = Array(n) { CharArray(n) }
    var ans = 0

    for (i in 0 until n) a[i] = readLine()!!.toCharArray()

    fun swap(startI: Int, startJ: Int, endI: Int, endJ: Int) {
        val temp = a[startI][startJ]
        a[startI][startJ] = a[endI][endJ]
        a[endI][endJ] = temp
    }

    fun check() {
        for (i in 0 until n) {
            var count = 1
            for (j in 0 until n - 1) {
                if (a[i][j] == a[i][j + 1]) {
                    count++
                } else {
                    ans = max(ans, count)
                    count = 1
                }
            }
            ans = max(ans, count)
        }

        for (j in 0 until n) {
            var count = 1
            for (i in 0 until n - 1) {
                if (a[i][j] == a[i + 1][j]) {
                    count++
                } else {
                    ans = max(ans, count)
                    count = 1
                }
            }
            ans = max(ans, count)
        }
    }

    for (i in 0 until n) {
        for (j in 0 until n) {
            if (j + 1 &amp;lt; n) {
                swap(i, j, i, j + 1)
                check()
                swap(i, j, i, j + 1)
            }

            if (i + 1 &amp;lt; n) {
                swap(i, j, i + 1, j)
                check()
                swap(i, j, i + 1, j)
            }
        }
    }

    println(ans)
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;제출하고 계속 틀려서 반례를 찾아보다 보니&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check()&lt;/code&gt;에서 count를 1로 초기화 안 해주어서 계속 틀렸었다.   &lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;풀면서 도움이 되었던 반례들


ZCY
ZCP
PYZ
-&amp;gt; 답:2

4
CCCC
YDYD
DYDY
YDYD
-&amp;gt; 답:4

2
CC
YY
-&amp;gt; 답:2

40
YYYYYYYYYCYYYYYYYYYYYYYYYCZZZZZZZYYYYYZC
PYPCYZCPYCZZCCPZYYPZYYYYPPZZPYCCCZYZZZPY
ZPPCYCCPYYZYPPZCZPYCCCZZYYPZZPYPPPPZPCZC
ZCYYZZYCPPPCCYPYYPZZZZCCCCZZCZCYCYZCZZYC
PYZYZZCCZZCCPPYCZPYPPZYZYYYZZPPCCZYYYZCZ
PPPCZZPCCCCCCCCCCCCCCCCCCYCZYYYZCYYCPCPZ
PZYPZYPPYYYZZZPPPZPYZPYZCZZPYZCZZPPCYCCZ
YPPYYYYCCPYPZPCPPPCZCZZYZZZZYYZPZZCCCZYY
YPZCZCPZYYZCCPPPYPPCCPCYZYYYCPPPYCYYCPYC
ZPYZCCZCYZYYCPCCPPYYZPYCCPPCPZCCZCCZYYPY
CPPPCPZZZCYCPYCZYZZPYPZCYYCCZCZZPZYCPZCZ
YZYCYPCPPYPPPPYYYPYPCPCPZZPPCYZCZPZZZZYP
ZCZPYZPPYYYPYPCZYZZYZZPZCZPPPZYCZYPCPYYC
YPZPZYCCYPZZCCPYYCYZYYYYYCZYZZYZZPPYCZCZ
YCZPZCCCCCYCCCCCCCCCCCZYPYZPCZPZZPZZYPYY
YYYYYYYYYYPYYYYYYYYYYYYYYYYYYYYYYYYYYZZP
ZYZCZZCCZPZCZYCPYPCCPYZYCCPPZZCZYCZCYPYP
YYZYPZZYCPCYCZPZYCZPZCCZYCCCZZZYYYZYYPCP
YZZPZYPYCZCPPCZPYCCPYCYZPCCYYZYPCPPPYYPZ
YYZPPZYCZZZYYPYCYZCCYYZPYCCYPZCCZCCCYYZC
CYZZPPCZYZYCCPCYYCPZPPZZPCZZYZZYZZCZYYPC
PPZYZYZPZZZZYPZYYPZPPZPPZCYCPZYZPPYYYYYZ
CZZZYPZYCCYYYPPZYCYPZPCCPCYYYZZYCPYCYCYY
YCZZCZCCYPPYYZYYYPPPZZYYCCCYYZZZYZZZYYCC
YCZPZPPPZPCYYYZZYCPPZYPZYCZZZZZPYYPYCYPC
PCZZZYYZCPCPCZYYYCPYZCCPZCZPYZZPYPZPYZYY
ZZZZPPPPPYZCZCPYYCCCCCCCCCCCYCCCCCCPCCCP
CPYCYZCZCZCYCPCYYCYZCZYYZCCPZZYZPZCPYCCP
YZZYYZZZZPZZCZCYYCZZPYZYCCPCPZYCYCZPYZPZ
YZZZZZZZZZZZZZZZZZZZZZZZCZZZZZZZZZZZZZZZ
YZZPPPPPPPPPPPPPPCPPPPPYYCYCZZZCCPCCYPYZ
YYZCPYPPYZPPYCZPYCZPCPCZZZCYCZYZCPCPZPZZ
CYZPCYYYYYYYYYYYYCYYYYYYYYYYYZYYCYZYPYZC
CPZCCZZZZZZZZZZZZCZZZZZZZZZZYZCCZCPZZCCY
YYZPCPZZCYYYYYCPYCZPYYYPPZZCCZZCPPPPCCPP
YYZZPCCYZCCCYPCYYPZCZZZZZPPYZCCCCCZCPPCY
PYYYYYYYYYYYYYYYYYYYYYYPYCZZPPYZYPPPPYCC
YPZCZPZYPZPPCYCZYCYPCCCZCZZCCZYZYYCYYZCZ
CPPZZPCYYCCCYCCPZPYYZYCYZYZYPYCPPZPCPCYC
ZPCYPYZPPCYYPYZZZPPZZZCCPYCYPCYYCYPPYCZY
답-&amp;gt;37

4
CCCP
CCCP
CCCP
CCCP
답-&amp;gt;4

3
YCP
CCY
YPC
답-&amp;gt;3

6
CCYYCC
YYCCYY
CCYYCC
YYCCYY
CCYYCC
YYCCYY
답-&amp;gt;3

5
CPZCC
ZYCPZ
CYYPZ
ZPZCC
CCPYY
답-&amp;gt;3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/commit/e4e7351efb5ef9f438a76f09dad56eca441ef02d&quot;&gt;github.com/beomjo/algorithm-study/commit/e4e7351efb5ef9f438a76f09dad56eca441ef02d&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 3085. 사탕게임</summary></entry><entry><title type="html">BOJ 1476. 날짜계산</title><link href="/boj/boj-1476/" rel="alternate" type="text/html" title="BOJ 1476. 날짜계산" /><published>2021-03-17T00:00:00+09:00</published><updated>2021-03-17T00:00:00+09:00</updated><id>/boj/boj-1476</id><content type="html" xml:base="/boj/boj-1476/">&lt;h2 id=&quot;boj1476날짜-계산&quot;&gt;&lt;strong&gt;BOJ 1476. 날짜 계산&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134815296-b916a432-f037-45fc-a6a0-d89f0bc88330.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134815298-d1b52a7d-549d-47c6-9438-f038df298758.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;(1 &amp;lt;= E &amp;lt;= 15) , (1 &amp;lt;= S &amp;lt;=28), (1 &amp;lt;= M &amp;lt;=19)&lt;br /&gt;
이므로 경우의 수는 15 * 28 * 19 = 7980으로 &lt;br /&gt;
1초 안에 수행할 수 있는 수 1억에 한참 못 미치는 숫자로, 여유 있게 구할 수 있으니&lt;br /&gt;
모든 경우의 수를 대입해 본다.&lt;/p&gt;

&lt;p&gt;경우의 수 1~7980을 각각 E (15), S(28), M(19)로 나누었을 때 나머지를 구하여서 &lt;br /&gt;
입력과 같은지 확인해보면 된다.&lt;/p&gt;

&lt;p&gt;입력받은 수에 모두 -1을 해주고&lt;br /&gt;
출력하기 전에 i에 +1을 해준다 (나머지 연산 예외처리 , ex) 15%15, 30%15.. 일 때 0이므로)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.util.Scanner;

class Main {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        int e = sc.nextInt() - 1;
        int m = sc.nextInt() - 1;
        int s = sc.nextInt() - 1;

        for (int i = 0; ; i++) {
            if (i % 15 == e &amp;amp;&amp;amp; i % 28 == m &amp;amp;&amp;amp; i % 19 == s) {
                System.out.println(i + 1);
                sc.close();
                System.exit(0);
            }
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.*
import kotlin.system.exitProcess

fun main() = with(Scanner(System.`in`)) {
    val e = nextInt() - 1
    val m = nextInt() - 1
    val s = nextInt() - 1

    var i = 0
    while (true) {
        if (i % 15 == e &amp;amp;&amp;amp; i % 28 == m &amp;amp;&amp;amp; i % 19 == s) {
            println(i + 1)
            exitProcess(0)
        }
        i++
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/commit/6b26ce6f92e3b115bc5dff1feea3691d64905959&quot;&gt;github.com/beomjo/algorithm-study/commit/6b26ce6f92e3b115bc5dff1feea3691d64905959&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 1476. 날짜 계산</summary></entry><entry><title type="html">BOJ 2309. 일곱 난쟁이</title><link href="/boj/boj-2309/" rel="alternate" type="text/html" title="BOJ 2309. 일곱 난쟁이" /><published>2021-03-17T00:00:00+09:00</published><updated>2021-03-17T00:00:00+09:00</updated><id>/boj/boj-2309</id><content type="html" xml:base="/boj/boj-2309/">&lt;h1 id=&quot;boj2309일곱난쟁이&quot;&gt;&lt;strong&gt;BOJ 2309. 일곱 난쟁이&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134815372-7f02e6e9-087c-4b10-8ba7-116432358c23.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;9 난쟁이 중 7 난쟁이가 아닌 2 난쟁이를 찾는 문제이니 나올 수 있는 경우의 수를 계산해보면&lt;br /&gt;
순서를 고려하지않고 n중 r을 찾는 경우이므로, 조합 nCr에 대입하면&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134815373-2c5b9938-cd0c-46a7-9ff0-edbe615f6313.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이므로 36이다.&lt;/p&gt;

&lt;p&gt;경우의 수가 적으니 모든 경우의 수에 대입하여 정답을 찾아보도록 한다.&lt;br /&gt;
7 난쟁이의 키의 합이 100이니 &lt;br /&gt;
7 난쟁이가 아닌 2명을 제외하였을 때 키가 100이면 정답이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;

class Main {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        int[] a = new int[9];
        int sum = 0;

        for (int i = 0; i &amp;lt; 9; i++) {
            a[i] = sc.nextInt();
            sum += a[i];
        }

        Arrays.sort(a);

        for (int i = 0; i &amp;lt; 9; i++) {
            for (int j = i + 1; j &amp;lt; 9; j++) {
                if ((sum - a[i] - a[j]) == 100) {
                    for (int k = 0; k &amp;lt; 9; k++) {
                        if (k != i &amp;amp;&amp;amp; k != j) {
                            System.out.println(a[k]);
                        }
                    }
                    sc.close();
                    System.exit(0);
                }
            }
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import kotlin.system.exitProcess

fun main() {
    val a = (0 until 9).map { readLine()!!.toInt() }.toList().sorted()
    val sum = a.sum()

    for (i in 0 until 9) {
        for (j in i + 1 until 9) {
            if ((sum - a[i] - a[j]) == 100) {
                (0 until 9)
                    .filter { it != i &amp;amp;&amp;amp; it != j }
                    .map { a[it] }
                    .forEach(::println)
                exitProcess(0);
            }
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/commit/50e5df0644164843f65b928f04d2b46d1468e9c7&quot;&gt;github.com/beomjo/algorithm-study/commit/50e5df0644164843f65b928f04d2b46d1468e9c7&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 2309. 일곱 난쟁이 풀이 9 난쟁이 중 7 난쟁이가 아닌 2 난쟁이를 찾는 문제이니 나올 수 있는 경우의 수를 계산해보면 순서를 고려하지않고 n중 r을 찾는 경우이므로, 조합 nCr에 대입하면 이므로 36이다. 경우의 수가 적으니 모든 경우의 수에 대입하여 정답을 찾아보도록 한다. 7 난쟁이의 키의 합이 100이니 7 난쟁이가 아닌 2명을 제외하였을 때 키가 100이면 정답이다.</summary></entry><entry><title type="html">BOJ 1912. 연속합</title><link href="/boj/boj-1912/" rel="alternate" type="text/html" title="BOJ 1912. 연속합" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-13T00:00:00+09:00</updated><id>/boj/boj-1912</id><content type="html" xml:base="/boj/boj-1912/">&lt;h1 id=&quot;boj-1912-연속합&quot;&gt;&lt;strong&gt;BOJ 1912. 연속합&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134815073-dd8e1101-2e2c-46ec-a2e0-8b1cf7f8ed10.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;d[i] = n개의 정수로 이루어진 임의의 수열 에서 i로 끝나는 연속합(연속된 몇 개의 수를 선택해서 구할 수 있는 값 중 가장 큰 값)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;임의의 수열에서 i로 끝나는 경우는 2가지가 있다&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;1. i-1번째와 i번째가 연속하는 경우 -&amp;gt; d[i-1]+arr[i]&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;2.i-1번째와 i번째가 연속하지 않는 경우 -&amp;gt; arr[i]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134815110-17a49328-f46e-4ec7-8753-76e9047be1fe.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;점화식&lt;br /&gt;
d[i] = max(arr[i], arr[i] + d[i-1])&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.util.Scanner;

class Main {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int[] d = new int[n];
        int[] arr = new int[n];

        for (int i = 0; i &amp;lt; n; i++) arr[i] = sc.nextInt();
        sc.close();

        d[0] = arr[0];

        for (int i = 1; i &amp;lt; n; i++) d[i] = Math.max(arr[i] + d[i - 1], arr[i]);

        int max = -1001;
        for (int i = 0; i &amp;lt; n; i++) {
            if (max &amp;lt; d[i]) {
                max = d[i];
            }
        }
        System.out.println(max);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import kotlin.math.max

fun main() {
    val n = readLine()!!.toInt()
    val arr = readLine()!!.split(&quot; &quot;).map { it.toInt() }
    val d = IntArray(n)

    d[0] = arr[0]
    for (i in 1 until n) d[i] = max(arr[i] + d[i - 1], arr[i])
    println(d.maxOf { it })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/commit/201d262b42354a89703765813faec885f4e7c603&quot;&gt;github.com/beomjo/algorithm-study/commit/201d262b42354a89703765813faec885f4e7c603&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 1912. 연속합</summary></entry><entry><title type="html">BOJ 1699. 제곱수의 합</title><link href="/boj/boj-1699/" rel="alternate" type="text/html" title="BOJ 1699. 제곱수의 합" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-13T00:00:00+09:00</updated><id>/boj/boj-1699</id><content type="html" xml:base="/boj/boj-1699/">&lt;h2 id=&quot;boj-1699-제곱수의-합&quot;&gt;&lt;strong&gt;BOJ 1699. 제곱수의 합&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134815178-5f8a1b76-a832-4563-8530-082bd99a61d7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;d[i] = i을 제곱수의 합으로 나타낼 수 있는 최소 항의 개수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 올 수 있는 수들은 1&lt;em&gt;1, 2&lt;/em&gt;2, 3&lt;em&gt;3….. j&lt;/em&gt;j이다.&lt;br /&gt;
즉 , O+O+O+O+…. (j*j) = i 으로 표현된다.&lt;/p&gt;

&lt;p&gt;(i - j&lt;em&gt;j) + (j&lt;/em&gt;j) = i로 표현할 수 있고, 마지막  j*j는 한 가지 방법이므로 +1이다.&lt;br /&gt;
(i - j*j) + 1 이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;점화식&lt;/strong&gt;&lt;br /&gt;
d[i] = min(d[i - j&lt;em&gt;j ]) +1
즉, d[i] = min(d[i], d[i - j&lt;/em&gt;j] +1) &lt;br /&gt;
1 &amp;lt;= j &amp;lt;= i&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.util.Scanner;

class Main {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] d = new int[n + 1]; // 최소항의 개수

        for (int i = 1; i &amp;lt;= n; i++) {
            d[i] = i;
            for (int j = 1; j * j &amp;lt;= i; j++) {
                d[i] = Math.min(d[i], d[i - j * j] + 1);
            }
        }

        System.out.println(d[n]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import kotlin.math.min

fun main() {
    val n = readLine()!!.toInt()
    val d = IntArray(n + 1)

    for (i in 1..n) {
        d[i] = i
        var j = 1
        while (j * j &amp;lt;= i) {
            d[i] = min(d[i], d[i - j * j] + 1)
            j++
        }
    }
    println(d[n])
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/commit/84ff043e04486adc457340873afd4aac6e3aa44c&quot;&gt;github.com/beomjo/algorithm-study/commit/84ff043e04486adc457340873afd4aac6e3aa44c&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 1699. 제곱수의 합</summary></entry><entry><title type="html">BOJ 14002. 가장 긴 증가하는 부분수열 4(LIS)</title><link href="/boj/boj-14002/" rel="alternate" type="text/html" title="BOJ 14002. 가장 긴 증가하는 부분수열 4(LIS)" /><published>2021-03-12T00:00:00+09:00</published><updated>2021-03-12T00:00:00+09:00</updated><id>/boj/boj-14002</id><content type="html" xml:base="/boj/boj-14002/">&lt;h1 id=&quot;boj-14002-가장-긴-증가하는-부분수열-4-lis&quot;&gt;&lt;strong&gt;BOJ 14002. 가장 긴 증가하는 부분수열 4 (LIS)&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134814980-322cb418-19a3-466d-a621-ef6de1de2052.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://beomseok95.tistory.com/355&quot;&gt;beomseok95.tistory.com/355&lt;/a&gt;&lt;/strong&gt;
위 문제와 같은 문제이지만 LIS의 길이뿐 아니라 모든 원소를 출력해야한다.&lt;br /&gt;
위 LIS 문제와 같이 푸는데, 역추적을 위한 배열을 만들어 LIS에 연결되는 인덱스를 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134815034-1b8a3bbf-4592-4768-9b43-06eeeb17deda.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.util.Scanner;
import java.util.Stack;

class Main {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        StringBuilder answer = new StringBuilder();
        int n = sc.nextInt();
        int[] arr = new int[n];
        int[] d = new int[n]; // 길이를 담을 배열
        int[] v = new int[n]; // 경로를 추적할 인덱스를 담을 배열
        int max = -1;
        int index = -1;

        for (int i = 0; i &amp;lt; n; i++) {
            arr[i] = sc.nextInt();
            d[i] = 1;
            v[i] = -1;
            for (int j = 0; j &amp;lt; i; j++) {
                if (arr[i] &amp;gt; arr[j] &amp;amp;&amp;amp; d[i] &amp;lt; d[j] + 1) {
                    d[i] = d[j] + 1;
                    v[i] = j;
                }
            }

            if (max &amp;lt; d[i]) {
                max = d[i];
                index = i;
            }
        }
        answer.append(max).append(&quot;\n&quot;);

        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;();
        while (index != -1) {
            stack.push(arr[index]);
            index = v[index];
        }

        while (!stack.isEmpty()) {
            answer.append(stack.pop()).append(&quot; &quot;);
        }

        sc.close();
        System.out.println(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.*

fun main() {
    val n = readLine()!!.toInt()
    val arr = readLine()!!.split(&quot; &quot;).map { it.toInt() }
    val d = IntArray(n) { 1 } // 길이를 담을 배열
    val v = IntArray(n) { -1 } // 경로를 추적할 인덱스를 담을 배열

    for (i in 0 until n) {
        for (j in 0 until i) {
            if (arr[i] &amp;gt; arr[j] &amp;amp;&amp;amp; d[i] &amp;lt; d[j] + 1) {
                d[i] = d[j] + 1
                v[i] = j
            }
        }
    }
    val maxLength = d.maxOf { it }
    var index = d.indexOf(maxLength)
    println(maxLength)

    val stack = Stack&amp;lt;Int&amp;gt;()
    while (index != -1) {
        stack.push(arr[index])
        index = v[index]
    }

    while (!stack.isEmpty()) {
        print(&quot;${stack.pop()} &quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/commit/2927f0207bb85c7dce70681a1aecef2d41903a2d&quot;&gt;github.com/beomjo/algorithm-study/commit/2927f0207bb85c7dce70681a1aecef2d41903a2d&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 14002. 가장 긴 증가하는 부분수열 4 (LIS)</summary></entry><entry><title type="html">BOJ 2193. 이친수</title><link href="/boj/boj-2193/" rel="alternate" type="text/html" title="BOJ 2193. 이친수" /><published>2021-03-05T00:00:00+09:00</published><updated>2021-03-05T00:00:00+09:00</updated><id>/boj/boj-2193</id><content type="html" xml:base="/boj/boj-2193/">&lt;h1 id=&quot;boj2193이친수&quot;&gt;&lt;strong&gt;BOJ 2193.  이친수&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134814808-0d28d75a-fbe5-4a95-8439-d4e5e41cf9fa.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;마지막으로 오는 수가 0 일 때 그 앞에 올 수 있는 수는 0,1이다.&lt;br /&gt;
마지막으로 오는 수가 1 일 때 그 앞에 올 수 있는 수는 0이다.&lt;/p&gt;

&lt;p&gt;점화식&lt;br /&gt;
d[i][0] = d[i-1][0] + d[i-1][1] &lt;br /&gt;
d[i][1] = d[i-1][0]&lt;/p&gt;

&lt;h3 id=&quot;bottom-up&quot;&gt;&lt;strong&gt;Bottom-Up&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.close();

        long[][] d = new long[n + 1][2];

        d[1][1] = 1;

        for (int i = 2; i &amp;lt;= n; i++) {
            for (int j = 0; j &amp;lt;= 1; j++) {
                if (j == 0) d[i][j] = d[i - 1][0] + d[i - 1][1];
                else d[i][j] = d[i - 1][0];
            }
        }
        System.out.println(d[n][0] + d[n][1]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main() {
   val n = readLine()!!.toInt()
   val d = Array(n + 1) { LongArray(2) }
   d[1][1] = 1

   for (i in 2..n) {
       for (j in 0..1) {
           d[i][j] = if (j == 0) d[i - 1][0] + d[i - 1][1] else d[i - 1][0]
       }
   }

   println(d[n][0] + d[n][1])
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;top-down&quot;&gt;&lt;strong&gt;Top-Down&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.Scanner;

class Main {
    static long[][] d = new long[91][2];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(go(n, 0) + go(n, 1));
    }

    static long go(int i, int j) {
        if (i == 1 &amp;amp;&amp;amp; j == 1) return 1;
        if (i == 1 &amp;amp;&amp;amp; j == 0) return 0;
        if (d[i][j] &amp;gt; 0) return d[i][j];

        if (j == 0) {
            d[i][j] = go(i - 1, 0) + go(i - 1, 1);
        } else {
            d[i][j] = go(i - 1, 0);
        }

        return d[i][j];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val d = Array(91) { LongArray(2) }

fun main() {
    val n = readLine()!!.toInt()
    println(go(n, 0) + go(n, 1))
}

fun go(i: Int, j: Int): Long {
    if (i == 1 &amp;amp;&amp;amp; j == 1) return 1
    if (i == 1 &amp;amp;&amp;amp; j == 0) return 0
    if (d[i][j] &amp;gt; 0) return d[i][j]

    d[i][j] = if (j == 0) go(i - 1, 0) + go(i - 1, 1) else go(i - 1, 0)

    return d[i][j]
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/commit/221467a4207833969f3527a5586429820482d6d9&quot;&gt;github.com/beomjo/algorithm-study/commit/221467a4207833969f3527a5586429820482d6d9&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 2193.  이친수</summary></entry><entry><title type="html">BOJ 11053. 가장 긴 증가하는 부분수열 (LIS)</title><link href="/boj/boj-11053/" rel="alternate" type="text/html" title="BOJ 11053. 가장 긴 증가하는 부분수열 (LIS)" /><published>2021-03-05T00:00:00+09:00</published><updated>2021-03-05T00:00:00+09:00</updated><id>/boj/boj-11053</id><content type="html" xml:base="/boj/boj-11053/">&lt;h1 id=&quot;boj-11053-가장-긴-증가하는-부분수열-lis&quot;&gt;&lt;strong&gt;BOJ 11053. 가장 긴 증가하는 부분수열 (LIS)&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;가장 긴 증가하는 부분수열(Longest Increasing Subsequece) [&lt;a href=&quot;https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4&quot;&gt;나무위키]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;어떤 임의의 수열이 주어질 때, 이 수열에서 몇 개의 수들을 제거해서 부분수열을 만들 수 있다.&lt;br /&gt;
이때 만들어진 부분수열 중 오름차순으로 정렬된 가장 긴 수열을 최장 증가 부분 수열이라 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134814873-10c9a8ef-0209-4c24-b66d-e67683511aa4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;d[i] = a[1], …… a[i] 까지 수열이 있을 때, a[i]를 마지막으로 하는 가장 긴 증가하는 부분수열의 길이&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를들어 a[1], a[2], a[3], a[4] …. a[i] 라는 수열이 있을 때 &lt;/p&gt;

&lt;p&gt;a[i]의 바로 전 수는 뭘까?&lt;br /&gt;
알 수없으므로 변수 j를 둔다.&lt;/p&gt;

&lt;p&gt;a[1], a[2], a[3], a[4] …. , a[j], a[i]&lt;br /&gt;
j 는 i보다 작고, a[j] &amp;lt; a[i]일때 LIS가 된다.&lt;/p&gt;

&lt;p&gt;점화식
d[i] = max(d[j]) + 1&lt;br /&gt;
j&amp;lt; 1 ,  a[i] &amp;gt; a[j]&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.util.Scanner;

class Main {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        int[] d = new int[n];
        int max = -1;

        for (int i = 0; i &amp;lt; n; i++) {
            arr[i] = sc.nextInt();
            d[i] = 1;
            for (int j = 0; j &amp;lt; i; j++) {
                if (arr[i] &amp;gt; arr[j]) {
                    d[i] = Math.max(d[i], d[j] + 1);
                }
            }

            if (max &amp;lt; d[i]) {
                max = d[i];
            }
        }
        sc.close();
        System.out.println(max);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import kotlin.math.max

fun main() {
    val n = readLine()!!.toInt()
    val arr = readLine()!!.split(&quot; &quot;).map { it.toInt() }
    val d = IntArray(n) { 1 }

    for (i in 0 until n) {
        for (j in 0 until i) {
            if (arr[i] &amp;gt; arr[j]) {
                d[i] = max(d[i], d[j] + 1)
            }
        }
    }

    println(d.maxOf { it })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/commit/0b4f0b0e945e335949409e9b9968b802733704bf&quot;&gt;github.com/beomjo/algorithm-study/commit/0b4f0b0e945e335949409e9b9968b802733704bf&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 11053. 가장 긴 증가하는 부분수열 (LIS) 가장 긴 증가하는 부분수열(Longest Increasing Subsequece) [나무위키] 어떤 임의의 수열이 주어질 때, 이 수열에서 몇 개의 수들을 제거해서 부분수열을 만들 수 있다. 이때 만들어진 부분수열 중 오름차순으로 정렬된 가장 긴 수열을 최장 증가 부분 수열이라 한다.</summary></entry><entry><title type="html">BOJ 10844. 쉬운 계단 수</title><link href="/boj/boj-10844/" rel="alternate" type="text/html" title="BOJ 10844. 쉬운 계단 수" /><published>2021-03-04T00:00:00+09:00</published><updated>2021-03-04T00:00:00+09:00</updated><id>/boj/boj-10844</id><content type="html" xml:base="/boj/boj-10844/">&lt;h1 id=&quot;boj10844쉬운계단수&quot;&gt;&lt;strong&gt;BOJ 10844. 쉬운 계단 수&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39984656/134814761-6e21576b-d7d6-414a-9f6d-e32cece99e28.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;d[i][j] = 길이 i의 마지막숫자가 j인 수의 개수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;길이 i의 마지막으로 오는수가 j일때 &lt;br /&gt;
마지막 수 j의 바로 전 수는 j+1 or j-1 일 수밖에 없다 (계단수는 인접한 모든 자릿수의 차이가 1이므로)&lt;br /&gt;
마지막 수 j로 끝났을 경우를 2차원 배열에 저장한다. &lt;br /&gt;
j가 0일때는 j+1만 올 수 있고, j가 9 일때는 j-1만 올 수 있음을 주의한다.&lt;/p&gt;

&lt;p&gt;점화식
d[i][j] = d[i-1][j-1] + d[i-1][j+1] , (1 &amp;lt; j &amp;lt;=9)&lt;/p&gt;

&lt;h3 id=&quot;bottom-up&quot;&gt;&lt;strong&gt;Bottom-Up&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long[][] d = new long[n + 1][10];
        long mod = 1_000_000_000L;

        for (int i = 1; i &amp;lt;= 9; i++) d[1][i] = 1;
        for (int i = 2; i &amp;lt;= n; i++) {
            for (int j = 0; j &amp;lt;= 9; j++) {
                if (j == 0) {
                    d[i][j] = (d[i - 1][j + 1]) % mod;
                } else if (j == 9) {
                    d[i][j] = (d[i - 1][j - 1]) % mod;
                } else {
                    d[i][j] = (d[i - 1][j - 1] + d[i - 1][j + 1]) % mod;
                }
            }
        }

        long result = 0;
        for (int i = 0; i &amp;lt;= 9; i++) result += d[n][i];
        System.out.println(result % mod);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main() {
    val n = readLine()!!.toInt()
    val d = Array(n + 1) { LongArray(10) }
    val mod = 1_000_000_000L

    for (i in 1..9) d[1][i] = 1
    for (i in 2..n) {
        for (j in 0..9) {
            d[i][j] = when (j) {
                0 -&amp;gt; (d[i - 1][j + 1]) % mod
                9 -&amp;gt; (d[i - 1][j - 1]) % mod
                else -&amp;gt; (d[i - 1][j - 1] + d[i - 1][j + 1]) % mod
            }
        }
    }
    (0..9).sumOf { d[n][it] }.let { it % mod }.let(::println)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;top-down&quot;&gt;&lt;strong&gt;Top-Down&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.Scanner;

class Main {
    static long[][] d = new long[101][10];
    static long mod = 1_000_000_000L;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        for (int j = 1; j &amp;lt;= 9; j++) d[1][j] = 1;

        long result = 0;
        for (int j = 0; j &amp;lt;= 9; j++) {
            result += (go(n, j) % mod);
        }

        System.out.println(result % mod);
    }

    static long go(int i, int j) {
        if (d[i][j] &amp;gt; 0 || i == 1) return d[i][j];

        if (j == 0) {
            d[i][j] = go(i - 1, j + 1) % mod;
        } else if (j == 9) {
            d[i][j] = go(i - 1, j - 1) % mod;
        } else {
            d[i][j] = (go(i - 1, j - 1) + go(i - 1, j + 1)) % mod;
        }

        return d[i][j] % mod;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val d = Array(101) { LongArray(10) }
const val mod = 1_000_000_000L

fun main() {
    val n = readLine()!!.toInt()
    for (i in 1..9) d[1][i] = 1

    ((0..9).sumOf { go(n, it) } % mod).let(::println)
}

fun go(i: Int, j: Int): Long {
    if (d[i][j] &amp;gt; 0 || i == 1) return d[i][j]

    d[i][j] = when (j) {
        0 -&amp;gt; go(i - 1, j + 1) % mod
        9 -&amp;gt; go(i - 1, j - 1) % mod
        else -&amp;gt; (go(i - 1, j + 1) + go(i - 1, j - 1)) % mod
    }

    return d[i][j] % mod
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;풀이소스&quot;&gt;풀이소스&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beomjo/algorithm-study/commit/7d1b464b3a06ce004cd071dc71af81c1ae751cd4#diff-1012b276a559252e4f3e8248e697ebbf45684020ae6683b2608c4a876d8b6fb8&quot;&gt;github.com/beomjo/algorithm-study/commit/7d1b464b3a06ce004cd071dc71af81c1ae751cd4#diff-1012b276a559252e4f3e8248e697ebbf45684020ae6683b2608c4a876d8b6fb8&lt;/a&gt;&lt;/p&gt;</content><author><name>beomjo</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><summary type="html">BOJ 10844. 쉬운 계단 수</summary></entry></feed>